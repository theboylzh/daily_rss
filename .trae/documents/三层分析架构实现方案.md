# 三层分析架构实现方案

## 一、整体架构设计

### 核心流程
1. **数据预处理**：提取新闻标题，生成Markdown列表格式
2. **第一层分析**：整体摘要分析，识别关键事件
3. **第二层分析**：三个关键事件的并行深度分析
4. **第三层分析**：基于前两层的综合分析
5. **结果整合**：生成最终分析报告

## 二、详细实现方案

### 1. 数据预处理模块

**修改现有方法**：
- `_batch_analyze_news`：改为调用新的三层分析流程
- `_call_ai_model`：重构为支持不同分析层级的通用方法

**新增方法**：
- `_preprocess_news`：提取新闻标题，生成Markdown列表
- `_format_news_as_markdown`：将新闻标题转换为Markdown格式

**实现细节**：
```python
def _preprocess_news(self, news_items: List[Dict[str, Any]]) -> str:
    """预处理新闻数据"""
    news_titles = [news['title'] for news in news_items]
    return self._format_news_as_markdown(news_titles)

def _format_news_as_markdown(self, news_titles: List[str]) -> str:
    """将新闻标题格式化为Markdown列表"""
    markdown = ""
    for i, title in enumerate(news_titles):
        markdown += f"- {title}\n"
    return markdown
```

### 2. 三层分析模块

**新增方法**：
- `_three_layer_analysis`：三层分析的主方法
- `_first_layer_analysis`：第一层整体摘要分析
- `_second_layer_analysis`：第二层关键事件深度分析（并行）
- `_third_layer_analysis`：第三层综合分析
- `_extract_key_events`：从第一层结果中提取关键事件
- `_analyze_single_event`：分析单个关键事件

**实现细节**：
```python
def _three_layer_analysis(self, news_items: List[Dict[str, Any]]) -> Dict[str, Any]:
    """三层分析主方法"""
    # 1. 预处理
    news_markdown = self._preprocess_news(news_items)
    
    # 2. 第一层分析
    first_layer_result = self._first_layer_analysis(news_markdown)
    
    # 3. 提取关键事件
    key_events = self._extract_key_events(first_layer_result)
    
    # 4. 第二层分析（并行）
    second_layer_results = self._second_layer_analysis(key_events)
    
    # 5. 第三层分析
    third_layer_result = self._third_layer_analysis(first_layer_result, second_layer_results)
    
    return {
        "first_layer": first_layer_result,
        "second_layer": second_layer_results,
        "third_layer": third_layer_result
    }
```

### 3. 并行处理实现

**使用技术**：
- `concurrent.futures.ThreadPoolExecutor`：实现并行分析
- 线程池大小：3（对应三个关键事件）

**实现细节**：
```python
def _second_layer_analysis(self, key_events: List[str]) -> List[str]:
    """并行分析关键事件"""
    from concurrent.futures import ThreadPoolExecutor, as_completed
    
    results = []
    
    # 只处理前3个关键事件
    events_to_analyze = key_events[:3]
    
    with ThreadPoolExecutor(max_workers=3) as executor:
        future_to_event = {
            executor.submit(self._analyze_single_event, event): event
            for event in events_to_analyze
        }
        
        for future in as_completed(future_to_event):
            event = future_to_event[future]
            try:
                result = future.result()
                results.append(result)
                print(f"完成事件分析: {event[:50]}...")
            except Exception as e:
                print(f"分析事件失败 {event[:50]}...: {e}")
                results.append(f"分析失败: {str(e)}")
    
    return results
```

### 4. 提示词管理

**预留提示词位置**：
- `self.prompts` 字典中添加三层分析的提示词
- 支持用户自定义提示词

**实现细节**：
```python
# 初始化提示词
self.prompts = {
    "first_layer": "# 第一层分析提示词\n\n请对以下新闻标题进行整体分析...",
    "second_layer": "# 第二层分析提示词\n\n请对以下事件进行深度分析...",
    "third_layer": "# 第三层分析提示词\n\n请基于以下分析结果进行综合分析..."
}
```

### 5. 结果处理与存储

**修改现有方法**：
- `analyze_daily_news`：集成三层分析结果
- `_generate_daily_summary`：基于三层分析结果生成摘要

**新增方法**：
- `_save_analysis_results`：保存Markdown格式的分析结果
- `_convert_to_final_report`：将三层分析结果转换为最终报告

**实现细节**：
```python
def _save_analysis_results(self, analysis_results: Dict[str, Any], date: str):
    """保存分析结果"""
    # 保存Markdown格式的分析结果
    markdown_report = self._convert_to_final_report(analysis_results)
    
    # 保存为Markdown文件
    md_file_path = os.path.join(self.daily_analysis_dir, f"{date}.md")
    with open(md_file_path, 'w', encoding='utf-8') as f:
        f.write(markdown_report)
    
    print(f"Markdown分析报告已保存: {md_file_path}")
```

## 三、技术特点

1. **最小成本实现**：基于现有代码结构，最小化修改
2. **并行处理**：第二层分析使用线程池并行处理，提高效率
3. **格式统一**：所有AI返回结果使用Markdown格式，便于处理和阅读
4. **可扩展性**：预留提示词位置，支持用户自定义
5. **容错机制**：各层分析失败时的备用方案

## 四、实现步骤

1. **第一阶段**：数据预处理模块实现
   - 修改数据预处理方法
   - 实现Markdown格式化

2. **第二阶段**：三层分析架构实现
   - 实现第一层分析
   - 实现关键事件提取
   - 实现第二层并行分析
   - 实现第三层综合分析

3. **第三阶段**：结果处理与优化
   - 实现结果整合
   - 实现报告生成
   - 性能优化

4. **第四阶段**：测试与验证
   - 功能测试
   - 性能测试
   - 错误处理测试

## 五、预期效果

- **处理速度**：相比现有实现，通过并行处理提高效率
- **分析深度**：三层分析逐步深入，确保分析质量
- **可维护性**：模块化设计，易于扩展和维护
- **用户体验**：结构化的分析报告，便于阅读和理解

## 六、关键技术点

1. **并行处理的实现**：使用ThreadPoolExecutor确保线程安全
2. **信息传递**：三层分析之间的Markdown格式信息传递
3. **错误处理**：各层分析的错误捕获和备用方案
4. **性能优化**：合理控制API调用频率和批次大小
5. **格式一致性**：确保所有分析结果的Markdown格式一致性

此方案充分考虑了用户需求和现有代码结构，通过最小成本实现了三层分析架构，既保证了分析的深度，又提高了处理效率。